# Lab4实验报告

## 1.实验题目

单周期CPU设计

## 2.实验目的

* 理解CPU的结构和工作原理
* 掌握单周期CPU的设计和调试方法
* 熟练掌握数据通路和控制器的设计和描述方法

## 3.实验平台

* Vivado 2019.3
* Fpga科大在线平台

## 4.实验过程

  * 设计CPU模块
    1. PC模块
    ```verilog
    `timescale 1ns / 1ps

    module PC(
            input clk,               //时钟信号
            input reset,             //重置信号，将PC的值置为0x0000_30000
            input jal,               //跳转分支信号
            input jalr,              //跳转分支信号
            input branch,            //分支信号
            input Z,                 //ZERO信号
            input [31:0] imm,        //立即数
            input [31:0] Reg_ReadData1,        //从寄存器读取数据
            output reg[31:0] curPC,  //现在的PC
            output reg[31:0] nextPC, //下一个PC
            output [31:0] PC_plus4,  //现在PC加上4
            output reg[7:0] PC_ins   //向取值器取得的PC
        );
        reg [31:0] PC_sub;

        initial begin
            curPC = 32'h00003000;
            nextPC = 32'h00003000;
        end
        
        //在时钟下降沿更改nextPC，避免数据冲突
        always@(negedge clk or posedge reset)
        begin
            if(reset) nextPC <= 32'h00003000;
            else if(jal)
            begin
                if(jalr) nextPC <= imm + Reg_ReadData1;
                else nextPC <= curPC + imm;
            end
            else
            begin
                if(branch)
                begin
                    if(Z) nextPC <= curPC + 4;
                    else nextPC <= curPC + imm;
                end
                else nextPC <= curPC + 4;
            end
        end

        //在时钟上升沿更改curPC的值
        always@(posedge clk or posedge reset)
        begin
            if(reset) //重置恢复
                    curPC <= 32'h00003000;
            else 
                    curPC <= nextPC;
        end

    assign PC_plus4 = curPC + 4;

    always@(*)
    begin
        PC_sub = curPC - 32'h00003000;
        PC_ins = PC_sub[9:2];
    end
    endmodule
    ```
    本模块实现了根据jal以及branch的指令改变nextPC的值，实现了一个类似于状态机的效果；

    本模块对应计算机组成的PC模块；

      2. InsMem模块
```verilog
`timescale 1ns / 1ps

module InsMEM(
        input [31:0] instr,      //获取当前指令
        output reg[7:0] op,      //操作码位段
        output reg[2:0] funct3,  //3位功能码位段
        output reg[6:0] funct7,  //7位功能码位段
        output reg[4:0] rs1,     //rs1地址位段
        output reg[4:0] rs2,     //rs2地址位段
        output reg[4:0] rd,      //rd地址位段
        output reg[31:0] imm     //立即数位段传给extend模块拼接扩展
    );

    initial begin
        op = 7'b0000000;
        funct3 = 3'b000;
        funct7 = 7'b0000000;
        rs1 = 5'b00000;
        rs2 = 5'b00000;
        imm = 32'h0;
    end

    //切割指令
    always@(instr) 
    begin
        op = instr[6:0];
        rs1 = instr[19:15];
        rs2 = instr[24:20];
        rd = instr[11:7];
        funct3 = instr[14:12];
        funct7 = instr[31:26];
        imm = instr[31:0];
    end
endmodule
```
本模块实现了分割指令的功能，使得funct3，funct7，以及Imm数段能够正确地进入UnitControl模块；

  3. ControlUnit模块
```verilog
`timescale 1ns / 1ps
//Control Unit
module ControlUnit(
        input [7:0] op,         //操作数
        input [2:0] funct3,     //3位功能码
        input [6:0] funct7,     //7位功能码
        output reg jal,         //是否跳转指令
        output reg branch,      //beq分支指令
        output reg[2:0] AluOp,  //ALU操作方式
        output reg AluSrc,      //ALU口位
        output reg[1:0] RegScr, //Rd输入数据来源(00:AluOutput;01:MemData;10:PC+4;11:ImmGen)
        output reg RegWrite,    //Rd写使能信
        output reg[2:0] ImmGen, //立即数拼接方法
        output reg Sign,        //立即数符号扩展信号
        output reg MemWrite,    //存储器写使能
        output reg jalr         //控制是PC的数值与偏移量相加，还是寄存器rs1的数值与偏移量相加
    );
    initial begin
        jal = 0;         //默认不跳转
        branch = 0;      //默认不跳转
        AluOp = 3'b000;  //默认ALU加法
        AluSrc = 0;      //默认选择读取rd2的数值
        RegScr = 2'b00;  //默认ALU输出为Rd输入
        RegWrite = 0;    //默认关闭写寄存器
        ImmGen = 3'b000; //默认拼接I型指令
        Sign = 1;        //默认带符号扩展
        MemWrite = 0;    //默认关闭写存储器
        jalr = 0;
    end

    always@(op or funct3 or funct7) 
    begin
        case(op)
            //R type
            7'b0110011:
            begin
                case(funct3)
                    //add&sub
                    3'b000:
                    begin
                        //add
                        if (funct7 == 7'b0000000) begin
                            jal = 0;
                            branch = 0;
                            AluOp = 3'b000;
                            AluSrc = 0;
                            RegScr = 2'b00;
                            RegWrite = 1;
                            ImmGen = 3'b000;
                            Sign = 1;
                            MemWrite = 0;
                            jalr = 0;
                        end
                        //sub
                        else begin
                            jal = 0;
                            branch = 0;
                            AluOp = 3'b001;
                            AluSrc = 0;
                            RegScr = 2'b00;
                            RegWrite = 1;
                            ImmGen = 3'b000;
                            Sign = 1;
                            MemWrite = 0;
                            jalr = 0;
                        end
                    end
                    
                    default: begin
                        jal = 0;         //默认不跳转
                        branch = 0;      //默认不跳转
                        AluOp = 3'b000;  //默认ALU加法
                        AluSrc = 0;      //默认选择读取rd2的数值
                        RegScr = 2'b00;  //默认ALU输出为Rd输入
                        RegWrite = 0;    //默认关闭写寄存器
                        ImmGen = 3'b000; //默认拼接I型指令
                        Sign = 1;        //默认带符号扩展
                        MemWrite = 0;      //默认关闭写存储器
                        jalr = 0;
                    end
                endcase
            end
            //I type1
            7'b0010011:
            begin
                case(funct3)
                    //addi
                    3'b000:
                    begin
                        jal = 0;
                        branch = 0;
                        AluOp = 3'b000;
                        AluSrc = 1;
                        RegScr = 2'b00;
                        RegWrite = 1;
                        ImmGen = 3'b000; //I型立即数拼接
                        Sign = 1; //有符号数拓展
                        MemWrite = 0;
                        jalr = 0;
                    end

                    default: begin
                        jal = 0;         //默认不跳转
                        branch = 0;      //默认不跳转
                        AluOp = 3'b000;  //默认ALU加法
                        AluSrc = 0;      //默认选择读取rd2的数值
                        RegScr = 2'b00;  //默认ALU输出为Rd输入
                        RegWrite = 0;    //默认关闭写寄存器
                        ImmGen = 3'b000; //默认拼接I型指令
                        Sign = 1;        //默认带符号扩展
                        MemWrite = 0;      //默认关闭写存储器
                        jalr = 0;
                    end
                endcase
            end
            //I type2
            7'b0000011:
            begin
                case(funct3)
                    //lw
                    3'b010:
                    begin
                        jal = 0;
                        branch = 0;
                        AluOp = 3'b000;
                        AluSrc = 1;
                        RegScr = 2'b01;
                        RegWrite = 1;
                        ImmGen = 3'b000; //I型立即数拼接
                        Sign = 1; //有符号数拓展
                        MemWrite = 0;
                        jalr = 0;
                    end

                    default: begin
                        jal = 0;         //默认不跳转
                        branch = 0;      //默认不跳转
                        AluOp = 3'b000;  //默认ALU加法
                        AluSrc = 0;      //默认选择读取rd2的数值
                        RegScr = 2'b00;  //默认ALU输出为Rd输入
                        RegWrite = 0;    //默认关闭写寄存器
                        ImmGen = 3'b000; //默认拼接I型指令
                        Sign = 1;        //默认带符号扩展
                        MemWrite = 0;      //默认关闭写存储器
                        jalr = 0;
                    end
                endcase
            end
            //S type
            7'b0100011:
            begin
                case(funct3)
                    //sw
                    3'b010:
                    begin
                        jal = 0;
                        branch = 0;
                        AluOp = 3'b000;
                        AluSrc = 1;
                        RegScr = 2'b00;
                        RegWrite = 0;
                        ImmGen = 3'b001;
                        Sign = 1;
                        MemWrite = 1;
                        jalr = 0;
                    end

                    default: begin
                        jal = 0;         //默认不跳转
                        branch = 0;      //默认不跳转
                        AluOp = 3'b000;  //默认ALU加法
                        AluSrc = 0;      //默认选择读取rd2的数值
                        RegScr = 2'b00;  //默认ALU输出为Rd输入
                        RegWrite = 0;    //默认关闭写寄存器
                        ImmGen = 3'b000; //默认拼接I型指令
                        Sign = 1;        //默认带符号扩展
                        MemWrite = 0;      //默认关闭写存储器
                        jalr = 0;
                    end
                endcase
            end
            //B type
            7'b1100011:
            begin
                case(funct3)
                    //beq
                    3'b000:
                    begin
                        jal = 0;
                        branch = 1;
                        AluOp = 3'b110;
                        AluSrc = 0;
                        RegScr = 2'b10;
                        RegWrite = 0;
                        ImmGen = 3'b010; //B型立即数拼接
                        Sign = 1; //有符号数拓展
                        MemWrite = 0;
                        jalr = 0;
                    end

                    //blt
                    3'b100:
                    begin
                        jal = 0;
                        branch = 1;
                        AluOp = 3'b101;
                        AluSrc = 0;
                        RegScr = 2'b10;
                        RegWrite = 0;
                        ImmGen = 3'b010; //B型立即数拼接
                        Sign = 1; //有符号数拓展
                        MemWrite = 0;
                        jalr = 0;
                    end

                    default: begin
                        jal = 0;         //默认不跳转
                        branch = 0;      //默认不跳转
                        AluOp = 3'b000;  //默认ALU加法
                        AluSrc = 0;      //默认选择读取rd2的数值
                        RegScr = 2'b00;  //默认ALU输出为Rd输入
                        RegWrite = 0;    //默认关闭写寄存器
                        ImmGen = 3'b000; //默认拼接I型指令
                        Sign = 1;        //默认带符号扩展
                        MemWrite = 0;      //默认关闭写存储器
                        jalr = 0;
                    end
                endcase
            end
            //J type
            7'b1101111:
            begin
                //jal
                    jal = 1;
                    branch = 0;
                    AluOp = 3'b000;
                    AluSrc = 0;
                    RegScr = 2'b10;
                    RegWrite = 1;
                    ImmGen = 3'b100; //J型立即数拼接
                    Sign = 1; //有符号数拓展
                    MemWrite = 0;
                    jalr = 0;
            end
            //I type3
            7'b1100111:
            begin
                case(funct3)
                    //jalr
                    3'b000:
                    begin
                        jal = 1;
                        branch = 0;
                        AluOp = 3'b000;
                        AluSrc = 0;
                        RegScr = 2'b10;
                        RegWrite = 1;
                        ImmGen = 3'b000; //I型立即数拼接
                        Sign = 1; //有符号数拓展
                        MemWrite = 0;
                        jalr = 1; //选择寄存器的数???与偏移量相??
                    end

                    default: begin
                        jal = 0;         //默认不跳转
                        branch = 0;      //默认不跳转
                        AluOp = 3'b000;  //默认ALU加法
                        AluSrc = 0;      //默认选择读取rd2的数值
                        RegScr = 2'b00;  //默认ALU输出为Rd输入
                        RegWrite = 0;    //默认关闭写寄存器
                        ImmGen = 3'b000; //默认拼接I型指令
                        Sign = 1;        //默认带符号扩展
                        MemWrite = 0;      //默认关闭写存储器
                        jalr = 0;
                    end
                endcase
            end
            
            //U type
            7'b0010111:
            //auipc
            begin
                jal = 0;
                branch = 0;
                AluOp = 3'b000;
                AluSrc = 0;
                RegScr = 2'b11; //立即数直接写
                RegWrite = 1;
                ImmGen = 3'b011; //U型立即数拼接
                Sign = 1; //有符号数拓展
                MemWrite = 0;
                jalr = 0;
            end

            default: begin
                        jal = 0;         //默认不跳转
                        branch = 0;      //默认不跳转
                        AluOp = 3'b000;  //默认ALU加法
                        AluSrc = 0;      //默认选择读取rd2的数值
                        RegScr = 2'b00;  //默认ALU输出为Rd输入
                        RegWrite = 0;    //默认关闭写寄存器
                        ImmGen = 3'b000; //默认拼接I型指令
                        Sign = 1;        //默认带符号扩展
                        MemWrite = 0;      //默认关闭写存储器
                        jalr = 0;
                    end
        endcase
    end
endmodule
```
本模块实现了根据进入的指令进行不同的信号处理，根据传入的指令判断输出相应的输出信号，如：jal，branch，ALuOp，AluSrc等，具体的含义已经在代码段注释中详细地阐明了，在此就不再赘述；

4. register_file

```verilog
`timescale 1ns / 1ps

module register_file
    (
    input clk, 
    input [4:0] ra0,
    output [31:0] rd0,
    input [4:0] ra1,
    output [31:0] rd1,
    input [4:0] ra2,
    output [31:0] rd2,
    input [4:0] wa,
    input RegWrite,
    input [31:0] wd
    );
    
    reg [31:0] registers[0:31];
    integer i;
    
    initial begin
        for (i = 0; i < 32; i = i+ 1) registers[i] = 0;
    end
    
    assign rd0 = (ra0 == 5'b0) ? 32'b0 : registers[ra0];
    assign rd1 = (ra1 == 5'b0) ? 32'b0 : registers[ra1];
    assign rd2 = (ra2 == 5'b0) ? 32'b0 : registers[ra2];
    
    always @(negedge clk) begin
        if(RegWrite) begin
            if(wa != {5'b0}) begin
                registers[wa] <= wd;
            end
        end
    end
endmodule
```
该模块是一个寄存器模块，根据之前实验导入，在本次实验中我们加入一个feature，即对应的x0寄存器的值总是零，不可以改变；

5. extend模块

```verilog
`timescale 1ns / 1ps
// 扩展立即数模块
module Extend(
        input [31:0] imm,    //立即数位段
        input Sign,          //扩展符号控制信号
        input [2:0] ExtSel,  //立即数拼接方式
        output reg [31:0] extend //扩展完成立即数
    );

    always@(imm or ExtSel or Sign)
    begin
        case (ExtSel)
            3'b000://I指令
            begin
                extend[11:0] = imm[31:20];
                extend[31:12] = Sign ? (imm[31] ? 20'hfffff : 20'h00000) : 20'h00000; //判断是否是有符号数
            end
			
            3'b001://S指令
            begin
                extend[4:0] = imm[11:7];
                extend[11:5] = imm[31:25];
                extend[31:12] = Sign ? (imm[31] ? 20'hfffff : 20'h00000) : 20'h00000;
            end

            3'b010://B指令
            begin
                extend[0] = 0; //扩展后的立即数第一位为零
                extend[11] = imm[7];
                extend[4:1] = imm[11:8];
                extend[10:5] = imm[30:25];
                extend[12] = imm[31];
                extend[31:13] = Sign ? (imm[31] ? 19'b1111111111111111111 : 19'b0000000000000000000) : 19'b0000000000000000000;
            end

            3'b011://U指令
            begin
                extend[11:0] = 12'h000;
                extend[31:12] = imm[31:12];
            end

            3'b100://J指令
            begin
                extend[0] = 0;
                extend[19:12] = imm[19:12];
                extend[11] = imm[20];
                extend[10:1] = imm[30:21];
                extend[20] = imm[31];
                extend[31:21] = Sign ? (imm[31] ? 11'b11111111111 : 11'b00000000000) : 11'b00000000000; //进行符号拓展
            end
        endcase
    end
endmodule
```
本模块是一个对立即数进行拓展的模块，他接受来自UnitControl的指令，并且如果发现了相应的拓展指令，那么他们就会对其进行相应的拓展，目前该模块可以支持对I指令，S指令，B指令，U指令，J指令的对应拓展，并且可以接受有符号数或者无符号数的拓展；

6. Alu模块

```verilog
`timescale 1ns / 1ps

module ALU(
        input ALUSrc,          //输入端1位选
        input [31:0] ReadData1, //rs1寄存器读取数据
        input [31:0] ReadData2, //rs2寄存器读取数据
        input [31:0] extend,    //扩展后立即数
        input [2:0] AluOp,      //ALU功能码
        output Z,           //Z表示示数为零
        output reg[31:0] AluOutput //ALU计算结果
    );

    wire [31:0] A;
    wire [31:0] B;

    //为两个输入端口赋值
    assign A = ReadData1;
    assign B = (ALUSrc == 0) ? ReadData2 : extend; //Mux选择器，由信号ALUSrc控制;
    always@(*) 
    begin
        //ALU部分
        case(AluOp)
            3'b000: AluOutput = A + B;
            3'b001: AluOutput = A - B;
            3'b010: AluOutput = A ^ B;
            3'b011: AluOutput = A | B;
            3'b100: AluOutput = A & B;
            3'b101: begin //比较A和B的大小，如果A小于B那么输出就置为1
                if((A[31] == 1)&&(B[31] == 0)) AluOutput = 1;
                else if((A[31] == 0)&&(B[31] == 1)) AluOutput = 0;
                else AluOutput = (A < B) ? 1 : 0;
            end
            3'b110: AluOutput = (A == B) ? 1 : 0;
            3'b111: begin //比较A和B的大小，如果A大于B那么输出就置为1
                if((A[31] == 1)&&(B[31] == 0)) AluOutput = 0;
                else if((A[31] == 0)&&(B[31] == 1)) AluOutput = 1;
                else AluOutput = (A > B) ? 1 : 0;
            end
        endcase;
    end

assign Z = (AluOutput == 0);
endmodule
```

本模块移植自之前的Lab1模块，并且针对本次实验增加了大于小于的判断；

7. 内存模块

```verilog
`timescale 1ns / 1ps
//data memory 数据存储器
module DataMEM(
        input MemWrite,        //存储器写使能
        input IoWrite,
        input clk,           //时钟信号，下降沿写入数据
        input [31:0] Mem_DataAddr1,  //写入存储器地址
        input [7:0] Mem_DataAddr2,   //PDU模块接口
        input [31:0] Mem_DataIn, //写入存储器数据
        output [31:0] Mem_DataOut1, //输出数据
        output [31:0] Mem_DataOut2  //PDU模块输出
    );

    reg [31:0] ram [0:255];     // 存储器
    integer i;
    wire [7:0] Mem_DataAddr_true;
    wire MemWrite_w;

    assign Mem_DataAddr_true = Mem_DataAddr1[9:2];
    assign MemWrite_w = (~IoWrite) & MemWrite;

    initial begin
        for (i = 0; i < 256; i = i+ 1) ram[i] = 0; //初始化
    end

    //读数据是组合逻辑电路
    assign Mem_DataOut1 = ram[Mem_DataAddr_true];
    assign Mem_DataOut2 = ram[Mem_DataAddr2];

    //写数据是时序逻辑电路
    always@(negedge clk)
    begin
        if(MemWrite_w) //写使能为1时写入数据
            begin
                ram[Mem_DataAddr_true] <= Mem_DataIn;
            end
    end
endmodule
```

本次实验共计拥有256个内存单元，并且每个内存是32字节的；写入应当是同步过程的，而读取是一个异步的过程；允许两个端口同时读取数据；

8. 选择器模块

```verilog
`timescale 1ns / 1ps
//选择寄存器写入的信号
module MUX_reg_input(
    input [1:0]RegScr,
    input [31:0]AluOutput,
    input [31:0]Mem_ReadData,
    input [31:0]PC_plus4,
    input [31:0]PC_Imm,
    output reg[31:0] Reg_WriteData
);

always@(*)
begin
    case(RegScr)
        2'b00: Reg_WriteData = AluOutput;
        2'b01: Reg_WriteData = Mem_ReadData;
        2'b10: Reg_WriteData = PC_plus4;
        2'b11: Reg_WriteData = PC_Imm;
        default: Reg_WriteData = 0;
    endcase
end
endmodule
```

该模块根据控制器发出的选择信号，选择是将哪一个数据写入进去寄存器；

9. CPU总模块

```verilog
`timescale 1ns / 1ps

module  cpu (
    input clk, 
    input reset,

  //IO_BUS
    output [7:0] io_addr,      //led和seg的地址
    output [31:0] io_dout,      //输出led和seg的数据
    output io_we,              //输出led和seg数据时的使能信号
    input [31:0] io_din,       //来自sw的输入数据

  //Debug_BUS
    input [7:0] m_rf_addr,     //存储器(MEM)或寄存器堆(RF)的调试读口地址
    output [31:0] rf_data,     //从RF读取的数据
    output [31:0] m_data,      //从MEM读取的数据
    output [31:0] pc_1         //PC的内容
);

wire [31:0] curPC;
wire [31:0] nextPC;
wire [31:0] PC_plus4; 
wire [7:0] PC_ins; 
wire [31:0] PC_Imm; //各种各样的PC地址

wire [7:0] op;
wire [2:0] funct3;
wire [6:0] funct7;
wire [4:0] Reg_ReadDataAddr1;
wire [4:0] Reg_ReadDataAddr2;
wire [4:0] Reg_WriteDataAddr;
wire [31:0] imm;
wire [31:0] instr; //获取到的32位指令

wire [31:0] Reg_ReadData1;
wire [31:0] Reg_ReadData2;
wire [31:0] Reg_WriteData; //寄存器模块读写数据

wire RegWrite; //寄存器写入控制信号
wire MemWrite; //存储器写入使能信号

wire [2:0] ExtSel;
wire [31:0] extend_imm; //输出的扩展后的立即数
wire sign; //是否是有符号数扩展控制信号

wire ALUSrc;
wire [2:0] AluOp;
wire Zero;
wire [31:0] AluOutput; //ALU模块的输出

wire [31:0] Mem_DataOut;
wire [31:0] Mem_DataOut_1; //数据存储器

wire [1:0] RegScr;
wire jal;
wire jalr;
wire branch;

wire [4:0] Reg_ReadDataAddr3;
wire IoWrite;

assign Reg_ReadDataAddr3 = m_rf_addr[4:0];
assign pc_1 = curPC;
assign io_addr = AluOutput[7:0];
assign io_dout = Reg_ReadData2;
assign IoWrite = AluOutput[10];
assign io_we = IoWrite & MemWrite;

PC pc(
    .clk(clk),
    .reset(reset),
    .jal(jal),
    .jalr(jalr),
    .branch(branch),
    .Z(Zero),
    .imm(extend_imm),
    .Reg_ReadData1(Reg_ReadData1),
    .curPC(curPC),
    .nextPC(nextPC),
    .PC_plus4(PC_plus4),
    .PC_ins(PC_ins)
);

ROM_Instruction ins(
  .a(PC_ins),
  .spo(instr)
);

InsMEM InsMem(
    .op(op),
    .funct3(funct3),
    .funct7(funct7),
    .rs1(Reg_ReadDataAddr1),
    .rs2(Reg_ReadDataAddr2),
    .rd(Reg_WriteDataAddr),
    .imm(imm),
    .instr(instr)
);

ControlUnit controlunit(
    .op(op),
    .funct3(funct3),
    .funct7(funct7),
    .jal(jal),
    .branch(branch),
    .AluOp(AluOp),
    .AluSrc(ALUSrc),
    .RegScr(RegScr),
    .RegWrite(RegWrite),
    .ImmGen(ExtSel),
    .Sign(sign),
    .MemWrite(MemWrite),
    .jalr(jalr)
);

register_file register_file(
    .clk(clk),
    .ra0(Reg_ReadDataAddr1),
    .ra1(Reg_ReadDataAddr2),
    .ra2(Reg_ReadDataAddr3),
    .wa(Reg_WriteDataAddr),
    .rd0(Reg_ReadData1),
    .rd1(Reg_ReadData2),
    .rd2(rf_data),
    .wd(Reg_WriteData),
    .RegWrite(RegWrite)
);

Extend extend(
    .imm(imm),
    .Sign(sign),
    .ExtSel(ExtSel),
    .extend(extend_imm)
);

ALU alu(
    .ALUSrc(ALUSrc),
    .ReadData1(Reg_ReadData1),
    .ReadData2(Reg_ReadData2),
    .extend(extend_imm),
    .AluOp(AluOp),
    .Z(Zero),
    .AluOutput(AluOutput)
);

DataMEM datamem(
    .MemWrite(MemWrite),
    .IoWrite(IoWrite),
    .clk(clk),
    .Mem_DataAddr1(AluOutput),
    .Mem_DataAddr2(m_rf_addr),
    .Mem_DataIn(Reg_ReadData2),
    .Mem_DataOut1(Mem_DataOut_1),
    .Mem_DataOut2(m_data)
);

assign Mem_DataOut = IoWrite ? io_din : Mem_DataOut_1;

assign PC_Imm = curPC + extend_imm;

MUX_reg_input mux(
    .RegScr(RegScr),
    .AluOutput(AluOutput),
    .Mem_ReadData(Mem_DataOut),
    .PC_plus4(PC_plus4),
    .Reg_WriteData(Reg_WriteData),
    .PC_Imm(PC_Imm)
);
endmodule
```

该模块是一个将各个模块连接起来，并且组成一个完整的CPU；

* PDU控制模块

```verilog
`timescale 1ns / 1ps

module  pdu_1cycle(
  input clk,
  input rst,

  //选择CPU工作方式;
  input run, 
  input step,
  output clk_cpu,

  //输入switch的端口
  input valid,
  input [4:0] in,

  //输出led和seg的端口 
  output [1:0] check,  //led6-5:查看类型
  output [4:0] out0,    //led4-0
  output [2:0] an,     //8个数码管
  output [3:0] seg,
  output ready,          //led7

  //IO_BUS
  input [7:0] io_addr,
  input [31:0] io_dout,
  input io_we,
  output [31:0] io_din,

  //Debug_BUS
  output [7:0] m_rf_addr,
  input [31:0] rf_data,
  input [31:0] m_data,
  input [31:0] pc
);

reg [4:0] in_r;    //同步外部输入用
reg run_r, step_r, step_2r, valid_r, valid_2r;
wire step_p, valid_pn;  //取边沿信号

reg clk_cpu_r;      //寄存器输出CPU时钟
reg [4:0] out0_r;   //输出外设端口
reg [31:0] out1_r;
reg ready_r;
reg [19:0] cnt;     //刷新计数器，刷新频率约为95Hz
reg [1:0] check_r;  //查看信息类型, 00-运行结果，01-寄存器堆，10-存储器，11-PC

reg [7:0] io_din_a; //_a表示为满足组合always描述要求定义的，下同
reg ready_a;
reg [4:0] out0_a;
reg [31:0] out1_a;
reg [3:0] seg_a;

assign clk_cpu = clk_cpu_r;
assign io_din = io_din_a;
assign check = check_r;
assign out0 = out0_a;
assign ready = ready_a;
assign seg = seg_a;
assign an = cnt[19:17];
assign step_p = step_r & ~step_2r;     //取上升沿
assign valid_pn = valid_r ^ valid_2r;  //取上升沿或下降沿
assign m_rf_addr = {{3{1'b0}}, in_r};

//同步输入信号
always @(posedge clk) begin
  run_r <= run;
  step_r <= step;
  step_2r <= step_r;
  valid_r <= valid;
  valid_2r <= valid_r;
  in_r <= in;           
end

//CPU工作方式
always @(posedge clk, posedge rst) begin
  if(rst)
    clk_cpu_r <= 0;
  else if (run_r)
    clk_cpu_r <= ~clk_cpu_r;
  else
    clk_cpu_r <= step_p;
end

//读外设端口
always @* begin
  case (io_addr)
    8'h0c: io_din_a = {{27{1'b0}}, in_r};
    8'h10: io_din_a = {{31{1'b0}}, valid_r};
    default: io_din_a = 32'h0000_0000;
  endcase
end

//写外设端口
always @(posedge clk, posedge rst) begin
if (rst) begin
  out0_r <= 5'h1f;
  out1_r <= 32'h1234_5678;
  ready_r <= 1'b1;
end
else if (io_we)
  case (io_addr)
    8'h00: out0_r <= io_dout[4:0];
    8'h04: ready_r <= io_dout[0];
    8'h08: out1_r <= io_dout;
    default: ;
  endcase
end

//LED和数码管查看类型
always @(posedge clk, posedge rst) begin
if(rst)
    check_r <= 2'b00;            
  else if(run_r)
    check_r <= 2'b00;
  else if (step_p)
    check_r <= 2'b00;
  else if (valid_pn)
    check_r <= check - 2'b01;
end

//LED和数码管显示内容
always @* begin
  ready_a = 1'b0;
  case (check_r)
    2'b00: begin
      out0_a = out0_r;
      out1_a = out1_r;
      ready_a = ready_r; 
    end
    2'b01: begin
      out0_a = in_r;
      out1_a = rf_data;
    end
    2'b10: begin
      out0_a = in_r;
      out1_a = m_data;
    end
    2'b11: begin
      out0_a = 5'b00000;
      out1_a = pc;
    end
  endcase
end

//扫描数码管
always @(posedge clk, posedge rst) begin
  if (rst) cnt <= 20'h0_0000;
  else cnt <= cnt + 20'h0_0001;
end

always @* begin
  case (an)
    3'd0: seg_a = out1_a[3:0];
    3'd1: seg_a = out1_a[7:4];
    3'd2: seg_a = out1_a[11:8];
    3'd3: seg_a = out1_a[15:12];
    3'd4: seg_a = out1_a[19:16];
    3'd5: seg_a = out1_a[23:20];
    3'd6: seg_a = out1_a[27:24];
    3'd7: seg_a = out1_a[31:28];
    default: ;
  endcase
end
endmodule
```

该模块由老师提供，本人并未修改；

* TOP_module模块

```verilog
`timescale 1ns / 1ps

module top(
    input clk,
    input rst,

    //选择CPU工作方式;
    input run, 
    input step,

    //输入switch的端口
    input valid,
    input [4:0] in,

    //输出led和seg的端口 
    output [1:0] check,  //led6-5:查看类型
    output [4:0] out0,    //led4-0
    output [2:0] an,     //8个数码管
    output [3:0] seg,
    output ready          //led7
);
//IO_BUS
wire [7:0] io_addr;
wire [31:0] io_dout;
wire io_we;
wire [31:0] io_din;

//Debug_BUS
wire [7:0] m_rf_addr;
wire [31:0] rf_data;
wire [31:0] m_data;
wire [31:0] pc;

wire clk_cpu;

pdu_1cycle pdu(
    .clk(clk),
    .rst(rst),
    .run(run),
    .step(step),
    .clk_cpu(clk_cpu),
    .valid(valid),
    .in(in),
    .check(check),
    .out0(out0),
    .an(an),
    .seg(seg),
    .ready(ready),
    .io_addr(io_addr),
    .io_dout(io_dout),
    .io_we(io_we),
    .io_din(io_din),
    .m_rf_addr(m_rf_addr),
    .rf_data(rf_data),
    .m_data(m_data),
    .pc(pc)
);

cpu cpu(
    .clk(clk_cpu),
    .reset(rst),
    .io_addr(io_addr),
    .io_dout(io_dout),
    .io_we(io_we),
    .io_din(io_din),
    .m_rf_addr(m_rf_addr),
    .rf_data(rf_data),
    .m_data(m_data),
    .pc_1(pc)
);

endmodule
```

该模块将PDU模块和CPU模块连到一起，使得PDU模块可以正确地控制CPU；



# 基于最短路径算法的导航软件

## 实验目的

要求在所给的数据集上建立图结构（邻接矩阵或者邻接表），并在建立的图结构上自行实现Dijkstra算 法求解任意两点之间的最短路径。

## 实验原理

* 本次实验我们利用Dijkstra算法实现最短路径算法导航，对于比较朴素的Dijkstra算法的实现来说还是非常简单的

  1. 我们首先使用邻接矩阵存储从文件中读取的图的数据，但值得注意的是，因为邻接矩阵存储稀疏图的效率非常低，所以我们不能存储点数过多的图，以免内存分配出错

  2. 普通的Dijkstra算法较为容易，时间复杂度为$ \Theta (|V|^{2})$，我们只需一个维护一个列表即可

  3. 实现Dijkstra的伪代码是：
     ```vhdl
     function Dijkstra(Graph, source):     
     	for each vertex v in Graph.Vertices:
         	dist[v] ← INFINITY
             prev[v] ← UNDEFINED
             add v to Q
     	dist[source] ← 0
            
     	while Q is not empty:
         	u ← vertex in Q with min dist[u]
             remove u from Q
               
     		for each neighbor v of u still in Q:
             	alt ← dist[u] + Graph.Edges(u, v)
                 if alt < dist[v]:
                 	dist[v] ← alt
                     prev[v] ← u
     
           	return dist[], prev[]
     ```

     

* 我们优化的方向从两个方面进行，一方面是优化稀疏图的存储方式，另一方面是优化时间复杂度

  * **优化稀疏图的存储方式**

    1. 从稀疏图的角度来说，我们优化了稀疏图的存储方式了，我们使用了类似于邻接表的存储方式使得空间复杂度从$\Theta(V^2)$降低到$\Theta(V+2E)$该方案在$E\ll V^2$的情况下能大为节约内存，并且我们从后续的过程中可以看出这个方案实现算法并不会增加明显的时间上的复杂度

    2. 我们使用了下列所示的存储结构存储稀疏图
       ```C
       typedef struct ArcNode{
           int adjvex;
           struct ArcNode *nextarc; //指向下一个邻接点
           int weight;
        }ArcNode; /* 表结点 */
       
       typedef struct VNode{
           ArcNode *firstarc; //指向第一个邻接点
        }VNode; /* 头结点 */
       ```

  * **优化时间复杂度**

    1. 对于一个Dijkstra算法来说，我们一共有$\Theta(|V|)$ 次插入操作, $\Theta(|E|)$更新操作,以及$\Theta(|V|)$次寻找删除最小值的操作

       * 如果使用传统的算法Dijkstra算法的时间复杂度为 $\Theta(|E| + |V|^2)$，当$|E| < |V|^2$时，时间复杂度为$\Theta(|V|^2)$

       * 如果使用二叉堆的话，我们对于上述的每一项操作都需要$log(|v|)$的时间复杂度，也就说一共需要 $\Theta(|E|log|V| + |V|log|V|)$的时间复杂度，对于$|E| > |V|$，我们有$\Theta(|E|log|V|)$。也就是说如果想要达到附加分二要求的时间复杂度来说，我们只需要实现二叉堆即可，但我们想在此基础上更进一步

       * 我们发现了Fibonacci堆，他的时间复杂度如下表所示

       | Operation | find-min |  delete-min  | insert | decrease-key |  meld  |
         | :-------: | :------: | :----------: | :----: | :----------: | :----: |
         | Fibonacci |  *Θ*(1)  | *O*(log *n*) | *Θ*(1) |    *Θ*(1)    | *Θ*(1) |
       
       * 也就是说如果我们使用Fibonacci堆实现Dijkstra算法的话，我们的时间复杂度能优化到$\Theta(|E| + |V|log|V|)$
       
    2. 下面是使用优先队列的伪代码：
       ```VHDL
       function Dijkstra(Graph, source):
       	dist[source] ← 0                           // Initialization
       
           create vertex priority queue Q
       
           for each vertex v in Graph.Vertices:
               if v ≠ source
                   dist[v] ← INFINITY                 // Unknown distance from source to v
                   prev[v] ← UNDEFINED                // Predecessor of v
       
               Q.add_with_priority(v, dist[v])
       
                     
            while Q is not empty:                      // The main loop
               u ← Q.extract_min()                    // Remove and return best vertex
               for each neighbor v of u:              // Go through all v neighbors of u
               	alt ← dist[u] + Graph.Edges(u, v)
               	if alt < dist[v]:
               		dist[v] ← alt
               		prev[v] ← u
               		Q.decrease_priority(v, alt)
       
       	return dist, prev
       ```
    
       